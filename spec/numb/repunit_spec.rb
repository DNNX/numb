describe Integer, "#repunit?" do
  REPUNITS = {
    10 => [1, 11, 111, 1111, 11111, 111111, 1111111, 11111111, 111111111],
    9 =>  [1, 10, 91, 820, 7381, 66430, 597871, 5380840, 48427561, 435848050],
    8 =>  [1, 9, 73, 585, 4681, 37449, 299593, 2396745, 19173961, 153391689],
    7 =>  [1, 8, 57, 400, 2801, 19608, 137257, 960800, 6725601, 47079208],
    6 =>  [1, 7, 43, 259, 1555, 9331, 55987, 335923, 2015539, 12093235],
    5 =>  [1, 6, 31, 156, 781, 3906, 19531, 97656, 488281, 2441406],
    4 =>  [1, 5, 21, 85, 341, 1365, 5461, 21845, 87381, 349525],
    3 =>  [1, 4, 13, 40, 121, 364, 1093, 3280, 9841, 29524],
    2 =>  [1, 3, 7, 15, 31, 63, 127, 255, 511, 1023],
  }
  REPUNITS.each do |base, members|
    members.each do |n|
      it "should return true for #{n} when base = #{base}" do
        n.repunit?(base).should be_true
      end

      m = n.odd? ? n - 1 : n + 2
      it "should return false for #{m} when base = #{base}" do
        m.repunit?(base).should be_false
      end
    end
  end
end

describe Integer, "#repunit" do
  # A002275
  @seq = [0,1,11,111,1111,11111,111111,1111111,11111111,
          111111111,1111111111,11111111111,111111111111,
          1111111111111,11111111111111,111111111111111,
          1111111111111111,11111111111111111,
          111111111111111111,1111111111111111111,
          11111111111111111111]
  
  @seq.each_with_index do |repunit, n|
    it "returns #{repunit} for #{n}" do
      n.repunit.should == repunit
    end
  end
end
